<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NetworkSocket</name>
    </assembly>
    <members>
        <member name="T:NetworkSocket.ByteBuilder">
            <summary>
            可变长byte集合 
            非线程安全类型
            多线程下请锁住自身的SyncRoot字段
            </summary>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.#ctor">
            <summary>
            可变长byte集合
            默认容量是1024byte
            </summary>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.#ctor(System.Int32)">
            <summary>
            可变长byte集合
            </summary>
            <param name="capacity">容量[乘2倍数增长]</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.Byte)">
            <summary>
            添加一个字节
            </summary>
            <param name="value">字节</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.Int16,NetworkSocket.Endians)">
            <summary>
            将16位整数转换为byte数组再添加
            </summary>
            <param name="value">整数</param>
            <param name="endian">高低位</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.UInt16,NetworkSocket.Endians)">
            <summary>
            将16位整数转换为byte数组再添加
            </summary>
            <param name="value">整数</param>
            <param name="endian">高低位</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.Int32,NetworkSocket.Endians)">
            <summary>
            将32位整数转换为byte数组再添加
            </summary>
            <param name="value">整数</param>
            <param name="endian">高低位</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.UInt32,NetworkSocket.Endians)">
            <summary>
            将32位整数转换为byte数组再添加
            </summary>
            <param name="value">整数</param>
            <param name="endian">高低位</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.Int64,NetworkSocket.Endians)">
            <summary>
            将64位整数转换为byte数组再添加
            </summary>
            <param name="value">整数</param>
            <param name="endian">高低位</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.UInt64,NetworkSocket.Endians)">
            <summary>
            将64位整数转换为byte数组再添加
            </summary>
            <param name="value">整数</param>
            <param name="endian">高低位</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.Byte[])">
            <summary>
            将指定数据源的数据添加到集合
            </summary>
            <param name="value">数据源</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Add(System.Byte[],System.Int32,System.Int32)">
            <summary>
            将指定数据源的数据添加到集合
            </summary>
            <param name="value">数据源</param>
            <param name="index">数据源的起始位置</param>
            <param name="length">复制的长度</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Remove(System.Int32)">
            <summary>
            从0位置删除指定长度的字节
            </summary>
            <param name="length">长度</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.CopyTo(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从0位置将数据复制到指定数组
            </summary>
            <param name="destArray">目标数组</param>
            <param name="index">目标数据索引</param>
            <param name="length">复制长度</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.CutTo(System.Byte[],System.Int32,System.Int32)">
            <summary>
            从0位置将数据剪切到指定数组
            </summary>
            <param name="destArray">目标数组</param>
            <param name="index">目标数据索引</param>
            <param name="length">剪切长度</param>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToByte(System.Int32)">
            <summary>
            返回指定位置的字节
            </summary>
            <param name="index">索引位置</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToInt16(System.Int32,NetworkSocket.Endians)">
            <summary>
            读取指定位置2个字节，返回其Int16表示类型
            </summary>
            <param name="index">字节所在索引</param>
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToUInt16(System.Int32,NetworkSocket.Endians)">
            <summary>
            读取指定位置2个字节，返回其UInt16表示类型
            </summary>
            <param name="index">字节所在索引</param>
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToInt32(System.Int32,NetworkSocket.Endians)">
            <summary>
            读取指定位置4个字节，返回其Int32表示类型
            </summary>
            <param name="index">字节所在索引</param>
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToUInt32(System.Int32,NetworkSocket.Endians)">
            <summary>
            读取指定位置4个字节，返回其UInt32表示类型
            </summary>
            <param name="index">字节所在索引</param>
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToInt64(System.Int32,NetworkSocket.Endians)">
            <summary>
            读取指定位置8个字节，返回其Int64表示类型
            </summary>
            <param name="index">字节所在索引</param>
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToUInt64(System.Int32,NetworkSocket.Endians)">
            <summary>
            读取指定位置8个字节，返回其UInt64表示类型
            </summary>
            <param name="index">字节所在索引</param>
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToArray">
            <summary>
            返回有效的数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToArray(System.Int32,System.Int32)">
            <summary>
            返回指定长度的数据
            </summary>
            <param name="index">索引</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.ToArrayThenClear">
            <summary>
            返回有效数据，并清空所有数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteBuilder.Clear">
            <summary>
            清空数据 
            容量不受到影响
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.ByteBuilder.Capacity">
            <summary>
            获取容量
            </summary>
        </member>
        <member name="P:NetworkSocket.ByteBuilder.Length">
            <summary>
            获取有效数量长度
            </summary>
        </member>
        <member name="P:NetworkSocket.ByteBuilder.SyncRoot">
            <summary>
            获取同步锁
            </summary>
        </member>
        <member name="P:NetworkSocket.ByteBuilder.Source">
            <summary>
            获取原始数据
            </summary>
        </member>
        <member name="T:NetworkSocket.ByteConverter">
            <summary>
            byte类型转换工具类
            提供byte和整型之间的转换
            </summary>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToInt64(System.Byte[],System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由字节数组中指定位置的8个字节转换来的64位有符号整数
            </summary>
            <param name="bytes">字节数组</param>
            <param name="startIndex">位置</param>    
            <param name="endian">高低位</param>
            <returns></returns>        
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToUInt64(System.Byte[],System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由字节数组中指定位置的8个字节转换来的64位无符号整数
            </summary>
            <param name="bytes">字节数组</param>
            <param name="startIndex">位置</param>    
            <param name="endian">高低位</param>
            <returns></returns>        
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToInt32(System.Byte[],System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由字节数组中指定位置的四个字节转换来的32位有符号整数
            </summary>
            <param name="bytes">字节数组</param>
            <param name="startIndex">位置</param>    
            <param name="endian">高低位</param>
            <returns></returns>        
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToUInt32(System.Byte[],System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由字节数组中指定位置的四个字节转换来的32位无符号整数
            </summary>
            <param name="bytes">字节数组</param>
            <param name="startIndex">位置</param>    
            <param name="endian">高低位</param>
            <returns></returns>        
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToInt16(System.Byte[],System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由字节数组中指定位置的四个字节转换来的16位有符号整数
            </summary>
            <param name="bytes">字节数组</param>
            <param name="startIndex">位置</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToUInt16(System.Byte[],System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由字节数组中指定位置的四个字节转换来的16位无符号整数
            </summary>
            <param name="bytes">字节数组</param>
            <param name="startIndex">位置</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToBytes(System.Int64,NetworkSocket.Endians)">
            <summary>
            返回由64位有符号整数转换为的字节数组
            </summary>
            <param name="value">整数</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToBytes(System.UInt64,NetworkSocket.Endians)">
            <summary>
            返回由64位无符号整数转换为的字节数组
            </summary>
            <param name="value">整数</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToBytes(System.Int32,NetworkSocket.Endians)">
            <summary>
            返回由32位有符号整数转换为的字节数组
            </summary>
            <param name="value">整数</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToBytes(System.UInt32,NetworkSocket.Endians)">
            <summary>
            返回由32位无符号整数转换为的字节数组
            </summary>
            <param name="value">整数</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToBytes(System.Int16,NetworkSocket.Endians)">
            <summary>
            返回由16位有符号整数转换为的字节数组
            </summary>
            <param name="value">整数</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.ByteConverter.ToBytes(System.UInt16,NetworkSocket.Endians)">
            <summary>
            返回由16位无符号整数转换为的字节数组
            </summary>
            <param name="value">整数</param>    
            <param name="endian">高低位</param>
            <returns></returns>
        </member>
        <member name="T:NetworkSocket.Endians">
            <summary>
            表示内存端枚举
            </summary>
        </member>
        <member name="F:NetworkSocket.Endians.Big">
            <summary>
            高位在前
            </summary>
        </member>
        <member name="F:NetworkSocket.Endians.Little">
            <summary>
            低位在前
            </summary>
        </member>
        <member name="T:NetworkSocket.Interfaces.ISocketAsync`1">
            <summary>
            异步Socket接口
            </summary>
            <typeparam name="T">协议类型</typeparam>
        </member>
        <member name="M:NetworkSocket.Interfaces.ISocketAsync`1.Send(`0)">
            <summary>
            异步发送数据
            </summary>
            <param name="packet">数据包</param>
        </member>
        <member name="P:NetworkSocket.Interfaces.ISocketAsync`1.TagBag">
            <summary>
            获取动态数据字典
            </summary>
        </member>
        <member name="P:NetworkSocket.Interfaces.ISocketAsync`1.RemoteEndPoint">
            <summary>
            获取远程终结点
            </summary>
        </member>
        <member name="P:NetworkSocket.Interfaces.ISocketAsync`1.IsConnected">
            <summary>
            获取是否已连接到远程端
            </summary>
        </member>
        <member name="T:NetworkSocket.Interfaces.ITcpClient`1">
            <summary>
            Tcp客户端接口
            </summary>
            <typeparam name="T">协议类型</typeparam>
        </member>
        <member name="M:NetworkSocket.Interfaces.ITcpClient`1.Close">
            <summary>      
            断开和远程终端的连接
            </summary>
        </member>
        <member name="M:NetworkSocket.Interfaces.ITcpClient`1.Connect(System.Net.IPEndPoint)">
            <summary>
            连接到远程终端 
            </summary>
            <param name="remoteEndPoint">远程ip和端口</param> 
            <returns></returns>
        </member>
        <member name="T:NetworkSocket.Interfaces.ITcpServer`1">
            <summary>
            Tcp服务接口
            </summary>
            <typeparam name="T">协议类型</typeparam>
        </member>
        <member name="M:NetworkSocket.Interfaces.ITcpServer`1.StartListen(System.Net.IPEndPoint)">
            <summary>
            开始启动监听
            </summary>
            <param name="localEndPoint">要监听的本地IP和端口</param>
        </member>
        <member name="M:NetworkSocket.Interfaces.ITcpServer`1.CloseClient(NetworkSocket.SocketAsync{`0})">
            <summary>
            关闭并复用客户端对象
            </summary>
            <param name="client">客户端对象</param>
        </member>
        <member name="P:NetworkSocket.Interfaces.ITcpServer`1.AliveClients">
            <summary>
            获取所有连接的客户端对象   
            </summary>
        </member>
        <member name="P:NetworkSocket.Interfaces.ITcpServer`1.LocalEndPoint">
            <summary>
            获取所监听的本地IP和端口
            </summary>
        </member>
        <member name="P:NetworkSocket.Interfaces.ITcpServer`1.IsListening">
            <summary>
            获取服务是否已处在监听中
            </summary>
        </member>
        <member name="T:NetworkSocket.SocketAsyncEventArgBuffer">
            <summary>
            SocketAsyncEventArgs缓冲区管理
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgBuffer.Instance">
            <summary>
            获取惟一实例 
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgBuffer.syncRoot">
            <summary>
            同步锁
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgBuffer.blockList">
            <summary>
            缓冲区块
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgBuffer.BlockItemBufferSize">
            <summary>
            获取每项缓存区大小(1024byte)
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgBuffer.BlockItemMaxCount">
            <summary>
            获取每块最大项数(1000项)     
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsyncEventArgBuffer.SetBuffer(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            设置缓存区
            </summary>        
            <param name="eventArg">参数</param>
        </member>
        <member name="M:NetworkSocket.SocketAsyncEventArgBuffer.Clear">
            <summary>
            清除所有数据块
            </summary>
        </member>
        <member name="P:NetworkSocket.SocketAsyncEventArgBuffer.BlockItemCount">
            <summary>
            获取当前块的项数
            </summary>
        </member>
        <member name="T:NetworkSocket.SocketAsyncEventArgPool">
            <summary>
            SocketAsyncEventArgs无序集合
            线程安全类型
            </summary>  
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgPool.Instance">
            <summary>
            获取惟一实例
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsyncEventArgPool.bag">
            <summary>
            无序集合
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsyncEventArgPool.Add(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            添加SocketAsync
            </summary>
            <param name="eventArg">SocketAsyncEventArgs对象</param>
        </member>
        <member name="M:NetworkSocket.SocketAsyncEventArgPool.Take">
            <summary>
            取出SocketAsyncEventArgs
            如果取出失败，则new新的SocketAsyncEventArgs并返回
            当触发Completed事件后将自动回收
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.SocketAsyncEventArgPool.Count">
            <summary>
            元素数量
            </summary>
        </member>
        <member name="T:NetworkSocket.Tasks.LimitedTask">
            <summary>
            表示限制并发数的任务
            </summary>
        </member>
        <member name="F:NetworkSocket.Tasks.LimitedTask.taskFactory">
            <summary>
            任务工厂
            </summary>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.#ctor(System.Int32)">
            <summary>
            限制并发数的任务
            </summary>
            <param name="maxConcurrencyLevel">最大并发数</param>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run(System.Action)">
            <summary>
            运行并返回一个任务
            </summary>
            <param name="action">要异步执行的操作委托</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run``1(System.Func{``0})">
            <summary>
            运行并返回一个任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="function">一个函数委托，可返回能够通过Task{TResult}获得的将来结果</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run(System.Action{System.Object},System.Object)">
            <summary>
            创建并启动一个任务
            </summary>
            <param name="action">要异步执行的操作委托</param>
            <param name="state">一个包含由 action 委托使用的数据的对象</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run(System.Action,System.Threading.CancellationToken)">
            <summary>
            创建并启动一个任务
            </summary>
            <param name="action">要异步执行的操作委托</param>
            <param name="cancellationToken">将指派给新任务的CancellationToken</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run(System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            创建并启动一个任务
            </summary>
            <param name="action">要异步执行的操作委托</param>
            <param name="creationOptions">一个 TaskCreationOptions 值</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run``1(System.Func{System.Object,``0},System.Object)">
            <summary>
            创建并启动一个任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="function">一个函数委托，可返回能够通过Task{TResult}获得的将来结果</param>
            <param name="state">一个包含由 function 委托使用的数据的对象</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>
            创建并启动一个任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="function">一个函数委托，可返回能够通过Task{TResult}获得的将来结果</param>
            <param name="cancellationToken">将指派给新任务的CancellationToken</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run``1(System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            创建并启动一个任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="function">一个函数委托，可返回能够通过Task{TResult}获得的将来结果</param>
            <param name="creationOptions">一个 TaskCreationOptions 值，用于控制创建的任务的行为</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run(System.Action{System.Object},System.Object,System.Threading.CancellationToken)">
            <summary>
            创建并启动一个任务
            </summary>
            <param name="action">要异步执行的操作委托</param>
            <param name="state">一个包含由 function 委托使用的数据的对象</param>
            <param name="cancellationToken">将指派给新任务的CancellationToken</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run(System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            创建并启动一个任务
            </summary>
            <param name="action">要异步执行的操作委托</param>
            <param name="state">一个包含由 function 委托使用的数据的对象</param>
            <param name="creationOptions">一个 TaskCreationOptions 值，用于控制创建的任务的行为</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run``1(System.Func{System.Object,``0},System.Object,System.Threading.CancellationToken)">
            <summary>
            创建并启动一个任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="function">一个函数委托，可返回能够通过Task{TResult}获得的将来结果</param>
            <param name="state">一个包含由 function 委托使用的数据的对象</param>
            <param name="cancellationToken">将指派给新任务的CancellationToken</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTask.Run``1(System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            创建并启动一个任务
            </summary>
            <typeparam name="T"></typeparam>
            <param name="function">一个函数委托，可返回能够通过Task{TResult}获得的将来结果</param>
            <param name="state">一个包含由 function 委托使用的数据的对象</param>
            <param name="creationOptions">一个 TaskCreationOptions 值，用于控制创建的任务的行为</param>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.Tasks.LimitedTask.MaxConcurrencyLevel">
            <summary>
            获取最大并发数
            </summary>
        </member>
        <member name="T:NetworkSocket.Tasks.LimitedTaskScheduler">
            <summary>
            并发限制任务调度器
            </summary>
            <summary> 
            </summary>
        </member>
        <member name="F:NetworkSocket.Tasks.LimitedTaskScheduler._currentThreadIsProcessingItems">
            <summary>
            当前线程是否处理任务
            </summary>
        </member>
        <member name="F:NetworkSocket.Tasks.LimitedTaskScheduler._tasks">
            <summary>
            待执行的任务链表
            </summary>
        </member>
        <member name="F:NetworkSocket.Tasks.LimitedTaskScheduler._maxDegreeOfParallelism">
            <summary>
            最大并发数
            </summary>
        </member>
        <member name="F:NetworkSocket.Tasks.LimitedTaskScheduler._delegatesQueuedOrRunning">
            <summary>
            调试器是否在处理任务
            </summary>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTaskScheduler.#ctor(System.Int32)">
            <summary>
            并发限制任务调度器
            </summary>
            <param name="maxDegreeOfParallelism">最大并发数</param>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTaskScheduler.QueueTask(System.Threading.Tasks.Task)">
            <summary>
            添加任务到队列中
            </summary>
            <param name="task"></param>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTaskScheduler.NotifyThreadPoolOfPendingWork">
            <summary>
            通知线程池有任务要执行
            </summary>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)">
            <summary>
            确定是否可以在此调用中同步执行提供的 System.Threading.Tasks.Task，如果可以，将执行该任务 
            </summary>
            <param name="task"></param>
            <param name="taskWasPreviouslyQueued"></param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTaskScheduler.TryDequeue(System.Threading.Tasks.Task)">
            <summary>
            尝试将以前排队到此计划程序中的Task取消排队
            </summary>
            <param name="task">要取消排队的Task</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Tasks.LimitedTaskScheduler.GetScheduledTasks">
            <summary>
            生成当前排队到计划程序中等待执行的Task实例的枚举
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.Tasks.LimitedTaskScheduler.MaximumConcurrencyLevel">
            <summary>
            指示能够支持的最大并发级别
            </summary>
        </member>
        <member name="T:NetworkSocket.TcpTable">
            <summary>
            提供获取Tcp端口快照信息
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpTable.Snapshot">
            <summary>
            获取一次Tcp端口快照信息
            </summary>
            <returns></returns>
        </member>
        <member name="T:NetworkSocket.TcpTable.MIB_TCPROW_OWNER_PID">
            <summary>
            端口进程信息
            </summary>
        </member>
        <member name="T:NetworkSocket.TcpTable.TcpPort">
            <summary>
            Tcp端口信息
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpTable.TcpPort.#ctor(System.Int32,System.Int32)">
            <summary>
            端口进程占用者信息
            </summary>
            <param name="port">端口</param>
            <param name="pid">进程ID</param>          
        </member>
        <member name="M:NetworkSocket.TcpTable.TcpPort.FromTcpRow(NetworkSocket.TcpTable.MIB_TCPROW_OWNER_PID)">
            <summary>
            从MIB_TCPROW_OWNER_PID对象获得数据
            </summary>
            <param name="row">MIB_TCPROW_OWNER_PID</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.TcpTable.TcpPort.Kill">
            <summary>
            杀死占用此端口的进程            
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpTable.TcpPort.GetHashCode">
            <summary>
            获取哈希值
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.TcpTable.TcpPort.Port">
            <summary>
            获取相关端口
            </summary>
        </member>
        <member name="P:NetworkSocket.TcpTable.TcpPort.OwnerPId">
            <summary>
            获取所占用的进程ID
            </summary>
        </member>
        <member name="T:NetworkSocket.Policies.FlexPolicyServer">
            <summary>
            Flex通讯策略服务
            </summary>
        </member>
        <member name="T:NetworkSocket.TcpServerBase`1">
            <summary>
            Tcp服务端抽象类
            提供对客户端池的初始化、自动回收重用、在线客户端列表维护功能
            提供客户端连接、断开通知功能
            所有Tcp服务端都派生于此类
            </summary>
            <typeparam name="T">PacketBase派生类型</typeparam>
        </member>
        <member name="F:NetworkSocket.TcpServerBase`1.listenSocket">
            <summary>
            服务socket
            </summary>
        </member>
        <member name="F:NetworkSocket.TcpServerBase`1.acceptArg">
            <summary>
            请求参数
            </summary>
        </member>
        <member name="F:NetworkSocket.TcpServerBase`1.clientPool">
            <summary>
            客户端连接池
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.#ctor">
            <summary>
            Tcp服务端抽象类
            </summary> 
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.StartListen(System.Int32)">
            <summary>
            开始启动监听
            </summary>
            <param name="port">端口</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.StartListen(System.Net.IPEndPoint)">
            <summary>
            开始启动监听
            </summary>
            <param name="localEndPoint">要监听的本地IP和端口</param>        
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.AcceptClient(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            开始一次接受连接请求操作
            </summary>
            <param name="arg">连接参数</param>     
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.ProcessAccept(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            处理连接请求
            </summary>
            <param name="arg">连接参数</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnReceive(NetworkSocket.SocketAsync{`0},NetworkSocket.ByteBuilder)">
            <summary>
            当接收到远程端的数据时，将触发此方法
            此方法用于处理和分析收到的数据
            如果得到一个数据包，将触发OnRecvComplete方法
            [注]这里只需处理一个数据包的流程
            </summary>
            <param name="client">客户端</param>
            <param name="recvBuilder">接收到的历史数据</param>
            <returns>如果不够一个数据包，则请返回null</returns>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnSend(NetworkSocket.SocketAsync{`0},`0)">
            <summary>
            发送之前触发
            </summary>      
            <param name="client">客户端</param>
            <param name="packet">数据包</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnRecvCompleteHandleWithTask(NetworkSocket.SocketAsync{`0},`0)">
            <summary>
            使用Task来处理OnRecvComplete业务方法
            重写此方法，使用LimitedTask来代替系统默认的Task可以控制并发数
            </summary>
            <param name="client">客户端</param>
            <param name="packet">封包</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnRecvComplete(NetworkSocket.SocketAsync{`0},`0)">
            <summary>
            当收到到数据包时，将触发此方法
            </summary>
            <param name="client">客户端</param>
            <param name="packet">数据包</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnClientDisconnect(NetworkSocket.SocketAsync{`0})">
            <summary>
            客户端socket关闭
            </summary>
            <param name="client">客户端</param>     
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnDisconnect(NetworkSocket.SocketAsync{`0})">
            <summary>
            当客户端断开连接时，将触发此方法
            </summary>
            <param name="client">客户端</param>     
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.OnConnect(NetworkSocket.SocketAsync{`0})">
            <summary>
            当客户端连接时，将触发此方法
            </summary>
            <param name="client">客户端</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.CloseClient(NetworkSocket.SocketAsync{`0})">
            <summary>
            关闭并复用客户端对象
            </summary>
            <param name="client">客户端对象</param>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.Dispose">
            <summary>
            关闭和释放所有相关资源
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpServerBase`1.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing">是否也释放托管资源</param>
        </member>
        <member name="P:NetworkSocket.TcpServerBase`1.AliveClients">
            <summary>
            获取所有连接的客户端对象   
            </summary>
        </member>
        <member name="P:NetworkSocket.TcpServerBase`1.LocalEndPoint">
            <summary>
            获取所监听的本地IP和端口
            </summary>
        </member>
        <member name="P:NetworkSocket.TcpServerBase`1.IsListening">
            <summary>
            获取服务是否已处在监听中
            </summary>
        </member>
        <member name="P:NetworkSocket.TcpServerBase`1.IsDisposed">
            <summary>
            获取对象是否已释放
            </summary>
        </member>
        <member name="M:NetworkSocket.Policies.FlexPolicyServer.StartListen">
            <summary>
            启动策略服务
            监听本地843端口       
            </summary>
        </member>
        <member name="M:NetworkSocket.Policies.FlexPolicyServer.OnReceive(NetworkSocket.SocketAsync{NetworkSocket.Policies.PolicyPacket},NetworkSocket.ByteBuilder)">
            <summary>
            接收到策略请求
            </summary>
            <param name="client">客户端</param>
            <param name="recvBuilder">数据</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Policies.FlexPolicyServer.OnRecvComplete(NetworkSocket.SocketAsync{NetworkSocket.Policies.PolicyPacket},NetworkSocket.Policies.PolicyPacket)">
            <summary>
            完成一次策略请求解析
            </summary>
            <param name="client">客户端</param>
            <param name="packet">请求的数据包</param>
        </member>
        <member name="P:NetworkSocket.Policies.FlexPolicyServer.Port">
            <summary>
            本地843端口
            </summary>
        </member>
        <member name="T:NetworkSocket.Policies.PolicyPacket">
            <summary>
            Flex或Silverlight安全策协议数据封包
            </summary>
        </member>
        <member name="T:NetworkSocket.PacketBase">
            <summary>
            通讯协议数据包抽象类
            要求所有协议实现此类的抽象方法
            </summary>
        </member>
        <member name="M:NetworkSocket.PacketBase.ToByteArray">
            <summary>
            转换为二进制数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Policies.PolicyPacket.ToByteArray">
            <summary>
            转换为二进制数据
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Policies.PolicyPacket.GetPacket(NetworkSocket.ByteBuilder)">
            <summary>
            解析收到的数据
            </summary>
            <param name="builder">数据</param>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.Policies.PolicyPacket.Bytes">
            <summary>
            获取或设置二进制数据
            </summary>
        </member>
        <member name="T:NetworkSocket.Policies.SilverlightPolicyServer">
            <summary>
            Siverlight通讯策略服务
            </summary>
        </member>
        <member name="M:NetworkSocket.Policies.SilverlightPolicyServer.StartListen">
            <summary>
            启动策略服务
            监听本地943端口
            </summary>
        </member>
        <member name="M:NetworkSocket.Policies.SilverlightPolicyServer.OnReceive(NetworkSocket.SocketAsync{NetworkSocket.Policies.PolicyPacket},NetworkSocket.ByteBuilder)">
            <summary>
            接收到策略请求
            </summary>
            <param name="client">客户端</param>
            <param name="recvBuilder">数据</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.Policies.SilverlightPolicyServer.OnRecvComplete(NetworkSocket.SocketAsync{NetworkSocket.Policies.PolicyPacket},NetworkSocket.Policies.PolicyPacket)">
            <summary>
            完成一次策略请求解析
            </summary>
            <param name="client">客户端</param>
            <param name="packet">请求的数据包</param>
        </member>
        <member name="P:NetworkSocket.Policies.SilverlightPolicyServer.Port">
            <summary>
            本地943端口
            </summary>
        </member>
        <member name="T:NetworkSocket.SocketAsyncCollection`1">
            <summary>
            SocketAsync集合 
            线程安全类型
            </summary>
            <typeparam name="T">数据类型</typeparam>
        </member>
        <member name="F:NetworkSocket.SocketAsyncCollection`1.dic">
            <summary>
            线程安全字典
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.#ctor">
            <summary>
            SocketAsync唯一集合
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.Add(NetworkSocket.SocketAsync{`0})">
            <summary>
            添加元素
            如果已包含此元素则返回false，同时不会增加记录
            </summary>
            <param name="socketAsync">元素</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.Remove(NetworkSocket.SocketAsync{`0})">
            <summary>
            移除元素
            如果元素不存在而返回false
            </summary>
            <param name="socketAsync">元素</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.Clear">
            <summary>
            清空所有元素
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.ToArray">
            <summary>
            将对象复制到数组中
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.ToList">
            <summary>
            将对象复制到列表中
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.Except(NetworkSocket.SocketAsync{`0})">
            <summary>
            通过使用默认的相等比较器对值进行比较得到集合的差集。
            </summary>
            <param name="client">客户端</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.GetEnumerator">
            <summary>
            获取枚举器
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsyncCollection`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            获取枚举器
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.SocketAsyncCollection`1.Count">
            <summary>
            获取元素的数量
            </summary>
        </member>
        <member name="T:NetworkSocket.SocketAsyncPool`1">
            <summary>
            SocketAsyn无序集合
            线程安全类型
            </summary>
            <typeparam name="T">PacketBase派生类型</typeparam>
        </member>
        <member name="F:NetworkSocket.SocketAsyncPool`1.bag">
            <summary>
            无序集合
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsyncPool`1.Add(NetworkSocket.SocketAsync{`0})">
            <summary>
            添加SocketAsync
            </summary>
            <param name="SocketAsync">SocketAsync对象</param>
        </member>
        <member name="M:NetworkSocket.SocketAsyncPool`1.Take">
            <summary>
            取出并返回SocketAsync
            如果取出失败，则new新的SocketAsync并返回
            </summary>
            <returns></returns>
        </member>
        <member name="P:NetworkSocket.SocketAsyncPool`1.Count">
            <summary>
            元素数量
            </summary>
        </member>
        <member name="T:NetworkSocket.TagBag">
            <summary>
            表示动态数据字典
            </summary>    
        </member>
        <member name="F:NetworkSocket.TagBag.dic">
            <summary>
            原始数据字典
            </summary>
        </member>
        <member name="M:NetworkSocket.TagBag.GetDynamicMemberNames">
            <summary>
            获取成员名称
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.TagBag.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>
            获取成员的值
            </summary>
            <param name="binder">成员</param>
            <param name="result">结果</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.TagBag.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>
            设置成员的值
            </summary>
            <param name="binder">成员</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.TagBag.Clear">
            <summary>
            清空内容
            </summary>
        </member>
        <member name="T:NetworkSocket.TcpClientBase`1">
            <summary>
            Tcp客户端抽象类
            所有Tcp客户端都派生于此类
            </summary>
            <typeparam name="T">PacketBase派生类型</typeparam>
        </member>
        <member name="T:NetworkSocket.SocketAsync`1">
            <summary>
            Socket上下文对象
            提供异步接收和发送方法
            </summary>
            <typeparam name="T">PacketBase派生类型</typeparam>
        </member>
        <member name="F:NetworkSocket.SocketAsync`1.socket">
            <summary>
            socket
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsync`1.socketRoot">
            <summary>
            socket排它锁
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsync`1.recvBuilder">
            <summary>
            接收到的未处理数据
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsync`1.recvEventArg">
            <summary>
            接收参数
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsync`1.RecvCompleteHandler">
            <summary>
            接收一个数据包委托
            </summary>
        </member>
        <member name="F:NetworkSocket.SocketAsync`1.DisconnectHandler">
            <summary>
            连接断开委托   
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.#ctor">
            <summary>
            异步Socket
            </summary>  
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.BindSocket(System.Net.Sockets.Socket)">
            <summary>
            将Socket对象与此对象绑定
            </summary>
            <param name="socket">套接字</param>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.SetKeepAlive(System.Net.Sockets.Socket)">
            <summary>
            设置客户端的心跳包
            </summary>
            <param name="socket">客户端</param>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.BeginReceive">
            <summary>
            开始接收数据
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.CloseSocket">
            <summary>
            将重置的未绑定Socket之前的状态
            包括释放socket对象，重置相关参数
            如果已重置过，将返回false
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.RecvCompleted(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            接收到数据事件
            </summary>
            <param name="sender">事件源</param>
            <param name="eventArg">参数</param>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.Send(`0)">
            <summary>
            异步发送数据
            </summary>
            <param name="package">数据包</param>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.Send(System.Byte[])">
            <summary>
            异步发送数据
            </summary>
            <param name="bytes">数据</param>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.ToString">
            <summary>
            字符串显示
            </summary>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.Dispose">
            <summary>
            关闭和释放所有相关资源
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.Finalize">
            <summary>
            析构函数
            </summary>
        </member>
        <member name="M:NetworkSocket.SocketAsync`1.Dispose(System.Boolean)">
            <summary>
            释放资源
            </summary>
            <param name="disposing">是否也释放托管资源</param>
        </member>
        <member name="P:NetworkSocket.SocketAsync`1.SendHandler">
            <summary>
            发送数据的委托
            </summary>
        </member>
        <member name="P:NetworkSocket.SocketAsync`1.ReceiveHandler">
            <summary>
            处理和分析收到的数据的委托
            </summary>
        </member>
        <member name="P:NetworkSocket.SocketAsync`1.TagBag">
            <summary>
            获取动态数据字典
            </summary>
        </member>
        <member name="P:NetworkSocket.SocketAsync`1.RemoteEndPoint">
            <summary>
            获取远程终结点
            </summary>
        </member>
        <member name="P:NetworkSocket.SocketAsync`1.IsConnected">
            <summary>
            获取是否已连接到远程端
            </summary>
        </member>
        <member name="P:NetworkSocket.SocketAsync`1.IsDisposed">
            <summary>
            获取是否已释放
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.#ctor">
            <summary>
            Tcp客户端抽象类
            </summary>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.Connect(System.Net.IPAddress,System.Int32)">
            <summary>
            连接到远程终端       
            </summary>
            <param name="ip">远程ip</param>
            <param name="port">远程端口</param>
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.Connect(System.Net.IPEndPoint)">
            <summary>
            连接到远程终端 
            </summary>
            <param name="remoteEndPoint">远程ip和端口</param> 
            <returns></returns>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.ConnectArg_Completed(System.Object,System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>
            连接完成事件
            </summary>
            <param name="sender">连接者</param>
            <param name="e">事件参数</param>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.OnReceive(NetworkSocket.ByteBuilder)">
            <summary>
            当接收到远程端的数据时，将触发此方法
            此方法用于处理和分析收到的数据
            如果得到一个数据包，将触发OnRecvComplete方法
            [注]这里只需处理一个数据包的流程
            </summary>
            <param name="recvBuilder">接收到的历史数据</param>
            <returns>如果不够一个数据包，则请返回null</returns>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.OnSend(`0)">
            <summary>
            发送之前触发
            </summary>
            <param name="packet">数据包</param>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.OnRecvCompleteHandleWithTask(`0)">
            <summary>
            使用Task来处理OnRecvComplete业务方法
            重写此方法，使用LimitedTask来代替系统默认的Task可以控制并发数
            </summary>       
            <param name="packet">封包</param>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.OnRecvComplete(`0)">
            <summary>
            当接收到数据包，将触发此方法
            </summary>
            <param name="packet">数据包</param>
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.OnDisconnect">
            <summary>
            当与服务器断开连接时，将触发此方法
            </summary>       
        </member>
        <member name="M:NetworkSocket.TcpClientBase`1.Close">
            <summary>
            断开和远程终端的连接
            </summary>
        </member>
    </members>
</doc>
